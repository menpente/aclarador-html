<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Aclarador - Herramienta de An√°lisis de Lenguaje Claro</title>

    <!-- Google Fonts - Poppins -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">

    <!-- External libraries for document parsing -->
    <script src="https://cdn.jsdelivr.net/npm/mammoth@1.6.0/mammoth.browser.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/pdfjs-dist@3.11.174/build/pdf.min.js"></script>
    <script>
        // Configure PDF.js worker
        if (typeof pdfjsLib !== 'undefined') {
            pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdn.jsdelivr.net/npm/pdfjs-dist@3.11.174/build/pdf.worker.min.js';
        }
    </script>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Poppins', Helvetica, Arial, Lucida, sans-serif;
            font-size: 14px;
            line-height: 1.7em;
            color: #000000;
            background: #ffffff;
        }

        .container {
            max-width: 1180px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            background: #000000;
            color: white;
            padding: 20px 30px;
            margin-bottom: 30px;
            border-radius: 0;
            box-shadow: none;
            display: flex;
            align-items: center;
            gap: 30px;
        }

        .header-logo {
            flex-shrink: 0;
        }

        .header-logo img {
            height: 70px;
            width: auto;
        }

        .header-content {
            flex: 1;
        }

        h1 {
            font-size: 1.8em;
            margin-bottom: 5px;
            font-weight: 600;
        }

        .subtitle {
            font-size: 1em;
            opacity: 0.8;
        }

        .controls {
            background: white;
            padding: 25px;
            border-radius: 0;
            margin-bottom: 20px;
            box-shadow: none;
            border: 1px solid #e2e8f0;
        }

        .control-group {
            margin-bottom: 20px;
        }

        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #555;
        }

        input[type="text"],
        input[type="password"] {
            width: 100%;
            padding: 12px;
            border: 1px solid #ddd;
            border-radius: 0;
            font-size: 14px;
            font-family: 'Poppins', Helvetica, Arial, Lucida, sans-serif;
            transition: border-color 0.3s;
        }

        input[type="text"]:focus,
        input[type="password"]:focus {
            outline: none;
            border-color: #ff0000;
        }

        .button-group {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        button {
            padding: 12px 24px;
            border: none;
            border-radius: 3px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-primary {
            background: #000000;
            color: #ffffff;
        }

        .btn-primary:hover:not(:disabled) {
            background: #ff0000;
            border-radius: 0;
        }

        .btn-secondary {
            background: #000000;
            color: #ffffff;
        }

        .btn-secondary:hover:not(:disabled) {
            background: #ff0000;
            border-radius: 0;
        }

        .btn-danger {
            background: #e10b17;
            color: #ffffff;
        }

        .btn-danger:hover:not(:disabled) {
            background: #ff0000;
            border-radius: 0;
        }

        .file-list {
            background: white;
            padding: 25px;
            border-radius: 0;
            margin-bottom: 20px;
            box-shadow: none;
            border: 1px solid #e2e8f0;
        }

        .file-item {
            display: flex;
            align-items: center;
            padding: 12px;
            border: 1px solid #e2e8f0;
            border-radius: 0;
            margin-bottom: 10px;
            transition: background 0.2s;
        }

        .file-item:hover {
            background: #f7fafc;
        }

        .file-item input[type="checkbox"] {
            margin-right: 12px;
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .file-info {
            flex: 1;
        }

        .file-name {
            font-weight: 600;
            color: #2d3748;
        }

        .file-meta {
            font-size: 0.85em;
            color: #718096;
            margin-top: 4px;
        }

        .file-status {
            padding: 4px 12px;
            border-radius: 0;
            font-size: 0.85em;
            font-weight: 500;
        }

        .status-pending {
            background: #e2e8f0;
            color: #4a5568;
        }

        .status-processing {
            background: #ffe5e5;
            color: #e10b17;
        }

        .status-completed {
            background: #c6f6d5;
            color: #22543d;
        }

        .status-error {
            background: #fed7d7;
            color: #742a2a;
        }

        .progress-section {
            background: white;
            padding: 25px;
            border-radius: 0;
            margin-bottom: 20px;
            box-shadow: none;
            border: 1px solid #e2e8f0;
            display: none;
        }

        .progress-section.active {
            display: block;
        }

        .progress-bar {
            width: 100%;
            height: 30px;
            background: #e2e8f0;
            border-radius: 0;
            overflow: hidden;
            margin: 15px 0;
        }

        .progress-fill {
            height: 100%;
            background: #ff0000;
            transition: width 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 600;
            font-size: 0.85em;
        }

        .results-section {
            margin-top: 30px;
        }

        .result-card {
            background: white;
            padding: 25px;
            border-radius: 0;
            margin-bottom: 20px;
            box-shadow: none;
            border: 1px solid #e2e8f0;
        }

        .result-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid #e2e8f0;
        }

        .result-title {
            font-size: 1.4em;
            font-weight: 700;
            color: #2d3748;
        }

        .text-comparison {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }

        .text-box {
            border: 1px solid #e2e8f0;
            border-radius: 0;
            padding: 15px;
            background: #f7fafc;
        }

        .text-box h3 {
            margin-bottom: 10px;
            color: #4a5568;
            font-size: 1.1em;
        }

        .text-content {
            line-height: 1.8;
            color: #2d3748;
            max-height: 300px;
            overflow-y: auto;
        }

        .scores {
            display: flex;
            gap: 20px;
            margin-top: 20px;
            flex-wrap: wrap;
        }

        .score-card {
            flex: 1;
            min-width: 150px;
            background: #000000;
            color: white;
            padding: 20px;
            border-radius: 0;
            text-align: center;
        }

        .score-value {
            font-size: 2.5em;
            font-weight: 700;
            margin-bottom: 5px;
        }

        .score-label {
            font-size: 0.9em;
            opacity: 0.9;
        }

        .empty-state {
            text-align: center;
            padding: 60px 20px;
            color: #718096;
        }

        .empty-state-icon {
            font-size: 4em;
            margin-bottom: 20px;
        }

        .collapsible {
            cursor: pointer;
            user-select: none;
        }

        .collapsible:hover {
            opacity: 0.8;
        }

        .collapsible-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease;
        }

        .collapsible-content.open {
            max-height: 500px;
            overflow-y: auto;
        }

        .api-key-group {
            position: relative;
        }

        .toggle-password {
            position: absolute;
            right: 12px;
            top: 38px;
            cursor: pointer;
            color: #718096;
            font-size: 0.9em;
        }

        .alert {
            padding: 15px 20px;
            border-radius: 0;
            margin-bottom: 20px;
        }

        .alert-info {
            background: #f5f5f5;
            color: #000000;
            border-left: 4px solid #000000;
        }

        .alert-error {
            background: #fff5f5;
            color: #000000;
            border-left: 4px solid #e10b17;
        }

        .alert-success {
            background: #f5fff5;
            color: #000000;
            border-left: 4px solid #22543d;
        }

        @media (max-width: 768px) {
            .text-comparison {
                grid-template-columns: 1fr;
            }

            h1 {
                font-size: 1.8em;
            }
        }

        .spinner {
            border: 3px solid #f3f3f3;
            border-top: 3px solid #ff0000;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
            display: inline-block;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <div class="header-logo">
                <img src="https://www.calamoycran.com/wp-content/uploads/logo-blog.png" alt="C√°lamo & Cran">
            </div>
            <div class="header-content">
                <h1>Aclarador - An√°lisis de Lenguaje Claro</h1>
                <p class="subtitle">Herramienta para analizar documentos usando principios de lenguaje claro</p>
            </div>
        </header>

        <div class="controls">
            <div class="control-group api-key-group">
                <label for="apiKey">Clave API de Groq:</label>
                <input type="password" id="apiKey" placeholder="Ingresa tu clave API de Groq">
                <span class="toggle-password" onclick="togglePasswordVisibility()">üëÅÔ∏è Mostrar</span>
            </div>

            <div class="control-group">
                <label>Seleccionar carpeta:</label>
                <div class="button-group">
                    <button class="btn-primary" onclick="selectFolder()">
                        üìÅ Seleccionar Carpeta
                    </button>
                    <button class="btn-secondary" id="analyzeBtn" onclick="analyzeSelectedFiles()" disabled>
                        ‚ú® Analizar Archivos Seleccionados
                    </button>
                    <button class="btn-secondary" id="analyzeAllBtn" onclick="analyzeAllFiles()" disabled>
                        üöÄ Analizar Todos
                    </button>
                </div>
            </div>
        </div>

        <div id="fileListSection" class="file-list" style="display: none;">
            <h2 style="margin-bottom: 20px;">üìÑ Archivos en la Carpeta</h2>
            <div id="fileList"></div>
        </div>

        <div id="progressSection" class="progress-section">
            <h2 style="margin-bottom: 15px;">‚è≥ Progreso del An√°lisis</h2>
            <div id="currentFile" style="margin-bottom: 10px; color: #4a5568;"></div>
            <div class="progress-bar">
                <div class="progress-fill" id="progressBar" style="width: 0%">0%</div>
            </div>
            <div style="text-align: center; color: #718096; margin-top: 10px;">
                <span id="filesProcessed">0</span> de <span id="totalFiles">0</span> archivos procesados
            </div>
        </div>

        <div id="resultsSection" class="results-section"></div>
    </div>

    <script>
        // ============================================================================
        // GLOBAL STATE
        // ============================================================================
        let selectedFiles = [];
        let analysisResults = [];
        let isProcessing = false;

        // ============================================================================
        // SYSTEM PROMPT (from aclarador-clean)
        // ============================================================================
        const SYSTEM_PROMPT = `Eres un experto en lenguaje claro basado en el Manual de Estilo del Gobierno de Arag√≥n.

PRINCIPIOS FUNDAMENTALES:
1. Expresar UNA SOLA IDEA por oraci√≥n
2. M√°ximo 30 palabras por oraci√≥n
3. Usar voz activa
4. Vocabulario com√∫n y preciso
5. Puntuaci√≥n estrat√©gica

CORRECCIONES ESPEC√çFICAS:
- Eliminar muletillas ("es decir", "o sea")
- Evitar redundancias
- Simplificar lenguaje burocr√°tico
- Sustituir nominalizaciones por verbos
- Convertir pasiva a activa

ADAPTACI√ìN DIGITAL:
- P√°rrafos cortos
- Subt√≠tulos descriptivos
- Formato escaneable
- Optimizaci√≥n SEO

Analiza el texto y proporciona mejoras espec√≠ficas.`;

        // ============================================================================
        // BASE AGENT CLASS
        // ============================================================================
        class BaseAgent {
            constructor(name) {
                this.name = name;
            }

            async analyze(text, context = {}) {
                throw new Error('analyze() must be implemented by subclass');
            }

            getCapabilities() {
                throw new Error('getCapabilities() must be implemented by subclass');
            }
        }

        // ============================================================================
        // ANALYZER AGENT
        // ============================================================================
        class AnalyzerAgent extends BaseAgent {
            constructor() {
                super('Analyzer');
            }

            async analyze(text, context = {}) {
                const classification = this._classifyText(text);
                const issues = this._detectIssues(text);
                const recommendedAgents = this._recommendAgents(classification, issues);
                const severity = this._assessSeverity(issues);

                return {
                    agent: this.name,
                    classification,
                    issues,
                    recommendedAgents,
                    severity
                };
            }

            getCapabilities() {
                return [
                    'text_classification',
                    'issue_detection',
                    'agent_routing',
                    'severity_assessment'
                ];
            }

            _classifyText(text) {
                const wordCount = text.split(/\s+/).length;
                if (wordCount < 100) return 'short';
                if (text.includes('meta') || text.includes('t√≠tulo') || text.includes('SEO')) {
                    return 'web';
                }
                return 'document';
            }

            _detectIssues(text) {
                const issues = [];
                const sentences = text.split(/[.!?]+/).filter(s => s.trim());

                sentences.forEach((sentence, idx) => {
                    const words = sentence.trim().split(/\s+/).length;
                    if (words > 30) {
                        issues.push({
                            type: 'sentence_length',
                            sentence: idx + 1,
                            words: words,
                            text: sentence.trim()
                        });
                    }
                });

                const longWords = text.match(/\b\w{13,}\b/g) || [];
                if (longWords.length > 0) {
                    issues.push({
                        type: 'complex_vocabulary',
                        count: longWords.length,
                        examples: longWords.slice(0, 3)
                    });
                }

                return issues;
            }

            _recommendAgents(classification, issues) {
                const agents = ['grammar', 'validator'];

                if (issues.length > 2 || classification === 'document') {
                    agents.unshift('style');
                }

                if (classification === 'web') {
                    agents.push('seo');
                }

                return agents;
            }

            _assessSeverity(issues) {
                if (issues.length >= 3) return 'high';
                if (issues.length >= 2) return 'medium';
                return 'low';
            }
        }

        // ============================================================================
        // REWRITER AGENT (uses Groq API)
        // ============================================================================
        class RewriterAgent extends BaseAgent {
            constructor() {
                super('Rewriter');
            }

            async analyze(text, context = {}) {
                const apiKey = getApiKey();
                if (!apiKey) {
                    throw new Error('API key requerida');
                }

                const issues = this._detectIssues(text);
                const prompt = this._buildRewritePrompt(text, issues);

                try {
                    const response = await fetch('https://api.groq.com/openai/v1/chat/completions', {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${apiKey}`,
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            model: 'llama-3.3-70b-versatile',
                            messages: [
                                { role: 'system', content: SYSTEM_PROMPT },
                                { role: 'user', content: prompt }
                            ],
                            temperature: 0.3,
                            max_tokens: 2000
                        })
                    });

                    if (!response.ok) {
                        throw new Error(`API error: ${response.status}`);
                    }

                    const data = await response.json();
                    const rewrittenText = data.choices[0].message.content;
                    const improvements = this._identifyImprovements(text, rewrittenText);

                    return {
                        agent: this.name,
                        originalText: text,
                        rewrittenText: rewrittenText,
                        improvements: improvements,
                        issuesDetected: issues
                    };
                } catch (error) {
                    console.error('Rewriter error:', error);
                    return {
                        agent: this.name,
                        error: error.message,
                        originalText: text,
                        rewrittenText: text
                    };
                }
            }

            getCapabilities() {
                return [
                    'comprehensive_rewriting',
                    'clarity_enhancement',
                    'structure_improvement',
                    'plain_language_conversion'
                ];
            }

            _detectIssues(text) {
                const issues = [];
                const sentences = text.split(/[.!?]+/).filter(s => s.trim());

                if (sentences.some(s => s.trim().split(/\s+/).length > 30)) {
                    issues.push('long_sentences');
                }

                if (text.match(/\b(fue|fueron|ha sido|han sido)\b/gi)) {
                    issues.push('passive_voice');
                }

                if (text.match(/\b\w{13,}\b/)) {
                    issues.push('complex_vocabulary');
                }

                return issues;
            }

            _buildRewritePrompt(text, issues) {
                let prompt = `Reescribe el siguiente texto aplicando principios de lenguaje claro.\n\n`;

                if (issues.includes('long_sentences')) {
                    prompt += `- Hay oraciones largas (>30 palabras). Div√≠delas.\n`;
                }
                if (issues.includes('passive_voice')) {
                    prompt += `- Convierte voz pasiva a activa.\n`;
                }
                if (issues.includes('complex_vocabulary')) {
                    prompt += `- Simplifica vocabulario complejo.\n`;
                }

                prompt += `\nTexto original:\n${text}`;
                return prompt;
            }

            _identifyImprovements(original, rewritten) {
                const improvements = [];

                const origSentences = original.split(/[.!?]+/).filter(s => s.trim());
                const rewritSentences = rewritten.split(/[.!?]+/).filter(s => s.trim());

                if (rewritSentences.length > origSentences.length) {
                    improvements.push({
                        type: 'structure',
                        change: 'Oraciones divididas para mayor claridad',
                        reason: 'Una idea por oraci√≥n (m√°ximo 30 palabras)'
                    });
                }

                const origAvg = origSentences.reduce((sum, s) => sum + s.split(/\s+/).length, 0) / origSentences.length;
                const rewAvg = rewritSentences.reduce((sum, s) => sum + s.split(/\s+/).length, 0) / rewritSentences.length;

                if (rewAvg < origAvg - 3) {
                    improvements.push({
                        type: 'sentence_length',
                        change: `Reducci√≥n promedio: ${origAvg.toFixed(1)} ‚Üí ${rewAvg.toFixed(1)} palabras`,
                        reason: 'Mejor legibilidad con oraciones m√°s cortas'
                    });
                }

                return improvements;
            }
        }

        // ============================================================================
        // GRAMMAR AGENT
        // ============================================================================
        class GrammarAgent extends BaseAgent {
            constructor() {
                super('Grammar');
            }

            async analyze(text, context = {}) {
                const issues = this._findGrammarIssues(text);

                return {
                    agent: this.name,
                    issues: issues,
                    correctedText: text // In real implementation, would apply corrections
                };
            }

            getCapabilities() {
                return [
                    'grammar_correction',
                    'punctuation_fixing',
                    'sentence_structure',
                    'agreement_checking'
                ];
            }

            _findGrammarIssues(text) {
                const issues = [];

                // Detect repeated words
                const repeatedWords = text.match(/\b(\w+)\s+\1\b/gi);
                if (repeatedWords) {
                    issues.push({
                        type: 'grammar',
                        issue: 'Palabras repetidas',
                        examples: repeatedWords.slice(0, 3),
                        recommendation: 'Eliminar repeticiones innecesarias'
                    });
                }

                return issues;
            }
        }

        // ============================================================================
        // STYLE AGENT
        // ============================================================================
        class StyleAgent extends BaseAgent {
            constructor() {
                super('Style');
            }

            async analyze(text, context = {}) {
                const issues = this._findStyleIssues(text);
                const readability = this._calculateReadability(text);

                return {
                    agent: this.name,
                    styleIssues: issues,
                    readabilityScore: readability
                };
            }

            getCapabilities() {
                return [
                    'sentence_simplification',
                    'jargon_removal',
                    'flow_improvement',
                    'readability_enhancement'
                ];
            }

            _findStyleIssues(text) {
                const issues = [];
                const sentences = text.split(/[.!?]+/).filter(s => s.trim());

                sentences.forEach((sentence, idx) => {
                    const words = sentence.trim().split(/\s+/).length;
                    if (words > 30) {
                        issues.push({
                            type: 'style',
                            issue: 'Oraci√≥n demasiado larga',
                            sentence: idx + 1,
                            words: words,
                            recommendation: 'Dividir en oraciones m√°s cortas'
                        });
                    }
                });

                // Detect passive voice
                if (text.match(/\b(fue|fueron|ha sido|han sido)\b/gi)) {
                    issues.push({
                        type: 'style',
                        issue: 'Posible voz pasiva',
                        recommendation: 'Usar voz activa para mayor claridad'
                    });
                }

                return issues;
            }

            _calculateReadability(text) {
                const sentences = text.split(/[.!?]+/).filter(s => s.trim());
                const avgLength = sentences.reduce((sum, s) =>
                    sum + s.split(/\s+/).length, 0) / sentences.length;

                // Simple readability score (0-1)
                // Optimal: 15 words per sentence
                const score = Math.max(0, Math.min(1, 1 - (Math.abs(avgLength - 15) / 30)));
                return parseFloat(score.toFixed(2));
            }
        }

        // ============================================================================
        // SEO AGENT
        // ============================================================================
        class SEOAgent extends BaseAgent {
            constructor() {
                super('SEO');
            }

            async analyze(text, context = {}) {
                const recommendations = this._analyzeSEOElements(text);
                const balance = this._assessClarityBalance(text);

                return {
                    agent: this.name,
                    seoRecommendations: recommendations,
                    clarityBalance: balance
                };
            }

            getCapabilities() {
                return [
                    'keyword_optimization',
                    'meta_description_review',
                    'clarity_seo_balance',
                    'search_intent_preservation'
                ];
            }

            _analyzeSEOElements(text) {
                const recommendations = [];
                const firstSentence = text.split(/[.!?]/)[0] || text;

                if (firstSentence.split(/\s+/).length > 10) {
                    recommendations.push({
                        type: 'seo',
                        element: 'title',
                        recommendation: 'Considerar acortar el t√≠tulo para SEO (m√°ximo 60 caracteres)',
                        reason: 'Los t√≠tulos largos pueden cortarse en resultados de b√∫squeda'
                    });
                }

                // Word frequency analysis
                const words = text.toLowerCase().split(/\s+/).filter(w => w.length > 4);
                const wordFreq = {};
                words.forEach(w => wordFreq[w] = (wordFreq[w] || 0) + 1);

                const repeatedWords = Object.entries(wordFreq)
                    .filter(([_, freq]) => freq > 3)
                    .map(([word, _]) => word);

                if (repeatedWords.length > 0) {
                    recommendations.push({
                        type: 'seo',
                        element: 'keywords',
                        recommendation: `Palabras clave frecuentes: ${repeatedWords.slice(0, 3).join(', ')}`,
                        reason: 'Equilibrar densidad de palabras clave con variedad'
                    });
                }

                return recommendations;
            }

            _assessClarityBalance(text) {
                const sentences = text.split(/[.!?]+/).filter(s => s.trim());
                const avgLength = sentences.reduce((sum, s) =>
                    sum + s.split(/\s+/).length, 0) / sentences.length;

                const clarityScore = Math.max(0, 1 - (avgLength - 15) / 30);

                return {
                    seoScore: 0.7,
                    clarityScore: parseFloat(clarityScore.toFixed(2)),
                    balanceScore: 0.65
                };
            }
        }

        // ============================================================================
        // VALIDATOR AGENT
        // ============================================================================
        class ValidatorAgent extends BaseAgent {
            constructor() {
                super('Validator');
            }

            async analyze(text, context = {}) {
                const validation = this._validateImprovements(text);
                const qualityScore = this._calculateQualityScore(text);
                const compliance = this._checkCompliance(text);

                return {
                    agent: this.name,
                    validation: validation,
                    qualityScore: qualityScore,
                    compliance: compliance
                };
            }

            getCapabilities() {
                return [
                    'quality_assurance',
                    'compliance_verification',
                    'final_review',
                    'scoring'
                ];
            }

            _validateImprovements(text) {
                const validations = [];
                const sentences = text.split(/[.!?]+/).filter(s => s.trim());

                sentences.forEach((sentence, idx) => {
                    const words = sentence.trim().split(/\s+/).length;
                    if (words > 30) {
                        validations.push({
                            status: 'warning',
                            message: `Oraci√≥n ${idx + 1} excede 30 palabras (${words})`,
                            recommendation: 'Considerar dividir la oraci√≥n'
                        });
                    } else if (words >= 15 && words <= 25) {
                        validations.push({
                            status: 'success',
                            message: `Oraci√≥n ${idx + 1} tiene longitud √≥ptima (${words} palabras)`
                        });
                    }
                });

                return validations;
            }

            _calculateQualityScore(text) {
                const sentences = text.split(/[.!?]+/).filter(s => s.trim());
                if (sentences.length === 0) return 0;

                let score = 0;
                sentences.forEach(sentence => {
                    const words = sentence.trim().split(/\s+/).length;
                    if (words >= 10 && words <= 30) {
                        score += (words >= 15 && words <= 25) ? 1 : 0.7;
                    } else {
                        score += 0.3;
                    }
                });

                return parseFloat((score / sentences.length).toFixed(2));
            }

            _checkCompliance(text) {
                const checks = [];

                checks.push({
                    criterion: 'Oraciones completas',
                    passed: text.split(/[.!?]+/).filter(s => s.trim()).length > 0
                });

                const sentences = text.split(/[.!?]+/).filter(s => s.trim());
                const avgLength = sentences.reduce((sum, s) =>
                    sum + s.split(/\s+/).length, 0) / sentences.length;

                checks.push({
                    criterion: 'Longitud promedio adecuada',
                    passed: avgLength <= 30
                });

                checks.push({
                    criterion: 'Puntuaci√≥n apropiada',
                    passed: text.includes('.') || text.includes('!') || text.includes('?')
                });

                checks.push({
                    criterion: 'Contenido no vac√≠o',
                    passed: text.trim().length > 0
                });

                return checks;
            }
        }

        // ============================================================================
        // AGENT COORDINATOR
        // ============================================================================
        class AgentCoordinator {
            constructor() {
                this.analyzer = new AnalyzerAgent();
                this.rewriter = new RewriterAgent();
                this.grammar = new GrammarAgent();
                this.style = new StyleAgent();
                this.seo = new SEOAgent();
                this.validator = new ValidatorAgent();
            }

            async processText(text, options = {}) {
                const results = {
                    originalText: text,
                    analysis: null,
                    rewriting: null,
                    grammar: null,
                    style: null,
                    seo: null,
                    validation: null,
                    finalText: text,
                    improvements: []
                };

                try {
                    // Step 1: Analyze
                    results.analysis = await this.analyzer.analyze(text);

                    // Step 2: Rewrite
                    results.rewriting = await this.rewriter.analyze(text);
                    let currentText = results.rewriting.rewrittenText || text;

                    if (results.rewriting.improvements) {
                        results.improvements.push(...results.rewriting.improvements);
                    }

                    // Step 3: Grammar
                    results.grammar = await this.grammar.analyze(currentText);
                    if (results.grammar.issues && results.grammar.issues.length > 0) {
                        results.improvements.push(...results.grammar.issues);
                    }

                    // Step 4: Style
                    results.style = await this.style.analyze(currentText);
                    if (results.style.styleIssues && results.style.styleIssues.length > 0) {
                        results.improvements.push(...results.style.styleIssues);
                    }

                    // Step 5: SEO (if web content)
                    if (results.analysis.classification === 'web') {
                        results.seo = await this.seo.analyze(currentText);
                        if (results.seo.seoRecommendations) {
                            results.improvements.push(...results.seo.seoRecommendations);
                        }
                    }

                    // Step 6: Validate
                    results.validation = await this.validator.analyze(currentText);
                    results.finalText = currentText;

                } catch (error) {
                    console.error('Processing error:', error);
                    results.error = error.message;
                }

                return results;
            }

            getAvailableAgents() {
                return {
                    analyzer: this.analyzer.getCapabilities(),
                    rewriter: this.rewriter.getCapabilities(),
                    grammar: this.grammar.getCapabilities(),
                    style: this.style.getCapabilities(),
                    seo: this.seo.getCapabilities(),
                    validator: this.validator.getCapabilities()
                };
            }
        }

        // ============================================================================
        // FILE SYSTEM AND UI FUNCTIONS
        // ============================================================================

        function getApiKey() {
            let apiKey = document.getElementById('apiKey').value.trim();
            if (!apiKey) {
                apiKey = localStorage.getItem('groqApiKey');
                if (apiKey) {
                    document.getElementById('apiKey').value = apiKey;
                }
            } else {
                localStorage.setItem('groqApiKey', apiKey);
            }
            return apiKey;
        }

        function togglePasswordVisibility() {
            const input = document.getElementById('apiKey');
            const toggle = document.querySelector('.toggle-password');
            if (input.type === 'password') {
                input.type = 'text';
                toggle.textContent = 'üôà Ocultar';
            } else {
                input.type = 'password';
                toggle.textContent = 'üëÅÔ∏è Mostrar';
            }
        }

        async function selectFolder() {
            if (!getApiKey()) {
                alert('Por favor, ingresa tu clave API de Groq primero.');
                return;
            }

            try {
                // Try modern File System Access API
                if ('showDirectoryPicker' in window) {
                    const dirHandle = await window.showDirectoryPicker();
                    await processDirectory(dirHandle);
                } else {
                    // Fallback for older browsers
                    alert('Tu navegador no soporta la selecci√≥n de carpetas. Usa Chrome, Edge o un navegador moderno.');
                }
            } catch (error) {
                if (error.name !== 'AbortError') {
                    console.error('Error selecting folder:', error);
                    alert('Error al seleccionar la carpeta: ' + error.message);
                }
            }
        }

        async function processDirectory(dirHandle) {
            selectedFiles = [];
            const fileList = document.getElementById('fileList');
            fileList.innerHTML = '';

            for await (const entry of dirHandle.values()) {
                if (entry.kind === 'file') {
                    const file = await entry.getFile();
                    // Filter text files
                    if (isTextFile(file.name)) {
                        selectedFiles.push({
                            name: file.name,
                            file: file,
                            handle: entry,
                            selected: true,
                            status: 'pending'
                        });
                    }
                }
            }

            if (selectedFiles.length === 0) {
                fileList.innerHTML = '<div class="empty-state"><div class="empty-state-icon">üì≠</div><p>No se encontraron archivos de texto en esta carpeta.</p></div>';
                return;
            }

            renderFileList();
            document.getElementById('fileListSection').style.display = 'block';
            document.getElementById('analyzeBtn').disabled = false;
            document.getElementById('analyzeAllBtn').disabled = false;
        }

        function isTextFile(filename) {
            const textExtensions = [
                // Plain text
                '.txt', '.md', '.markdown', '.rst', '.adoc',
                // Web
                '.html', '.htm', '.css', '.scss', '.sass', '.less',
                // JavaScript/TypeScript
                '.js', '.jsx', '.ts', '.tsx', '.mjs', '.cjs',
                // Data formats
                '.json', '.xml', '.yaml', '.yml', '.csv', '.toml',
                // Programming languages
                '.py', '.java', '.cpp', '.c', '.h', '.hpp', '.cs',
                '.go', '.rs', '.rb', '.php', '.swift', '.kt', '.scala',
                '.r', '.m', '.sh', '.bash', '.zsh', '.ps1',
                // Other
                '.log', '.sql', '.tex', '.bib',
                // Binary formats (will be parsed)
                '.docx', '.pdf'
            ];
            return textExtensions.some(ext => filename.toLowerCase().endsWith(ext));
        }

        async function extractTextFromFile(file) {
            const filename = file.name.toLowerCase();

            try {
                // Handle Word documents
                if (filename.endsWith('.docx')) {
                    return await extractTextFromDocx(file);
                }

                // Handle PDF files
                if (filename.endsWith('.pdf')) {
                    return await extractTextFromPdf(file);
                }

                // Handle all other text files
                return await file.text();

            } catch (error) {
                console.error(`Error extracting text from ${file.name}:`, error);
                throw new Error(`No se pudo leer el archivo: ${error.message}`);
            }
        }

        async function extractTextFromDocx(file) {
            if (typeof mammoth === 'undefined') {
                throw new Error('Mammoth library no cargada. Recarga la p√°gina.');
            }

            const arrayBuffer = await file.arrayBuffer();
            const result = await mammoth.extractRawText({ arrayBuffer: arrayBuffer });

            if (!result.value || result.value.trim().length === 0) {
                throw new Error('El documento DOCX est√° vac√≠o o no contiene texto extra√≠ble');
            }

            return result.value;
        }

        async function extractTextFromPdf(file) {
            if (typeof pdfjsLib === 'undefined') {
                throw new Error('PDF.js library no cargada. Recarga la p√°gina.');
            }

            const arrayBuffer = await file.arrayBuffer();
            const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;

            let fullText = '';

            for (let pageNum = 1; pageNum <= pdf.numPages; pageNum++) {
                const page = await pdf.getPage(pageNum);
                const textContent = await page.getTextContent();
                const pageText = textContent.items.map(item => item.str).join(' ');
                fullText += pageText + '\n\n';
            }

            if (!fullText.trim()) {
                throw new Error('El PDF est√° vac√≠o o no contiene texto extra√≠ble');
            }

            return fullText;
        }

        function renderFileList() {
            const fileList = document.getElementById('fileList');
            fileList.innerHTML = '';

            selectedFiles.forEach((fileObj, index) => {
                const fileItem = document.createElement('div');
                fileItem.className = 'file-item';

                const statusClass = `status-${fileObj.status}`;
                const statusText = {
                    'pending': 'Pendiente',
                    'processing': 'Procesando...',
                    'completed': 'Completado',
                    'error': 'Error'
                }[fileObj.status];

                fileItem.innerHTML = `
                    <input type="checkbox"
                           ${fileObj.selected ? 'checked' : ''}
                           onchange="toggleFileSelection(${index})"
                           ${isProcessing ? 'disabled' : ''}>
                    <div class="file-info">
                        <div class="file-name">${fileObj.name}</div>
                        <div class="file-meta">${formatFileSize(fileObj.file.size)}</div>
                    </div>
                    <span class="file-status ${statusClass}">${statusText}</span>
                `;

                fileList.appendChild(fileItem);
            });
        }

        function toggleFileSelection(index) {
            selectedFiles[index].selected = !selectedFiles[index].selected;
            const selectedCount = selectedFiles.filter(f => f.selected).length;
            document.getElementById('analyzeBtn').disabled = selectedCount === 0;
        }

        function formatFileSize(bytes) {
            if (bytes < 1024) return bytes + ' B';
            if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
            return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
        }

        async function analyzeSelectedFiles() {
            const filesToAnalyze = selectedFiles.filter(f => f.selected);
            await analyzeFiles(filesToAnalyze);
        }

        async function analyzeAllFiles() {
            selectedFiles.forEach(f => f.selected = true);
            await analyzeFiles(selectedFiles);
        }

        async function analyzeFiles(files) {
            if (isProcessing) return;

            if (!getApiKey()) {
                alert('Por favor, ingresa tu clave API de Groq.');
                return;
            }

            isProcessing = true;
            document.getElementById('analyzeBtn').disabled = true;
            document.getElementById('analyzeAllBtn').disabled = true;

            const progressSection = document.getElementById('progressSection');
            progressSection.classList.add('active');

            document.getElementById('totalFiles').textContent = files.length;
            document.getElementById('filesProcessed').textContent = '0';

            const resultsSection = document.getElementById('resultsSection');
            resultsSection.innerHTML = '';

            const coordinator = new AgentCoordinator();

            for (let i = 0; i < files.length; i++) {
                const fileObj = files[i];

                // Update progress
                document.getElementById('currentFile').textContent = `Procesando: ${fileObj.name}`;
                const progress = Math.round(((i) / files.length) * 100);
                const progressBar = document.getElementById('progressBar');
                progressBar.style.width = progress + '%';
                progressBar.textContent = progress + '%';

                fileObj.status = 'processing';
                renderFileList();

                try {
                    // Read file (supports .txt, .docx, .pdf, and more)
                    const text = await extractTextFromFile(fileObj.file);

                    // Process with coordinator
                    const result = await coordinator.processText(text);

                    fileObj.status = 'completed';
                    fileObj.result = result;

                    // Display result
                    displayResult(fileObj);

                } catch (error) {
                    console.error(`Error processing ${fileObj.name}:`, error);
                    fileObj.status = 'error';
                    fileObj.error = error.message;
                    displayError(fileObj);
                }

                renderFileList();
                document.getElementById('filesProcessed').textContent = (i + 1).toString();
            }

            // Final progress update
            const progressBar = document.getElementById('progressBar');
            progressBar.style.width = '100%';
            progressBar.textContent = '100%';
            document.getElementById('currentFile').textContent = '¬°An√°lisis completado!';

            isProcessing = false;
            document.getElementById('analyzeBtn').disabled = false;
            document.getElementById('analyzeAllBtn').disabled = false;
        }

        function displayResult(fileObj) {
            const resultsSection = document.getElementById('resultsSection');
            const result = fileObj.result;

            const card = document.createElement('div');
            card.className = 'result-card';

            const qualityScore = result.validation?.qualityScore || 0;
            const readabilityScore = result.style?.readabilityScore || 0;

            card.innerHTML = `
                <div class="result-header">
                    <div class="result-title">üìÑ ${fileObj.name}</div>
                    <button class="btn-primary" onclick="downloadCorrectedFile('${fileObj.name}', ${resultsSection.children.length})">
                        üíæ Descargar Corregido
                    </button>
                </div>

                <div class="text-comparison">
                    <div class="text-box">
                        <h3>üìã Original</h3>
                        <div class="text-content">${escapeHtml(result.originalText.substring(0, 500))}${result.originalText.length > 500 ? '...' : ''}</div>
                    </div>
                    <div class="text-box">
                        <h3>‚ú® Mejorado</h3>
                        <div class="text-content">${escapeHtml(result.finalText.substring(0, 500))}${result.finalText.length > 500 ? '...' : ''}</div>
                    </div>
                </div>

                <div class="scores">
                    <div class="score-card">
                        <div class="score-value">${(qualityScore * 100).toFixed(0)}%</div>
                        <div class="score-label">Calidad</div>
                    </div>
                    <div class="score-card">
                        <div class="score-value">${(readabilityScore * 100).toFixed(0)}%</div>
                        <div class="score-label">Legibilidad</div>
                    </div>
                    <div class="score-card">
                        <div class="score-value">${result.analysis?.severity || 'N/A'}</div>
                        <div class="score-label">Severidad</div>
                    </div>
                </div>
            `;

            resultsSection.appendChild(card);
        }

        function displayError(fileObj) {
            const resultsSection = document.getElementById('resultsSection');
            const card = document.createElement('div');
            card.className = 'result-card';
            card.innerHTML = `
                <div class="result-header">
                    <div class="result-title">üìÑ ${fileObj.name}</div>
                </div>
                <div class="alert alert-error">
                    ‚ùå Error al procesar: ${fileObj.error}
                </div>
            `;
            resultsSection.appendChild(card);
        }

        function downloadCorrectedFile(filename, index) {
            const fileObj = selectedFiles.find(f => f.name === filename);
            if (!fileObj || !fileObj.result) return;

            const correctedText = fileObj.result.finalText;
            const blob = new Blob([correctedText], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);

            const a = document.createElement('a');
            a.href = url;
            a.download = filename.replace(/(\.[^.]+)$/, '_corregido$1');
            a.click();

            URL.revokeObjectURL(url);
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // ============================================================================
        // INITIALIZATION
        // ============================================================================

        window.addEventListener('DOMContentLoaded', () => {
            // Load API key from localStorage if available
            const savedApiKey = localStorage.getItem('groqApiKey');
            if (savedApiKey) {
                document.getElementById('apiKey').value = savedApiKey;
            }
        });
    </script>
</body>
</html>
